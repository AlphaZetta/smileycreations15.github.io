(function(){var moduleCache={};moduleCache["2-factor-auth.js"]='// 2 factor auth\nfunction makeid(length) {\n   var result           = "";\n   var characters       = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";\n   var charactersLength = characters.length;\n   for ( var i = 0; i < length; i++ ) {\n      result += characters.charAt(Math.floor(Math.random() * charactersLength));\n   }\n   return result;\n}\nfunction encode(string) {\n    var number = "0x";\n    var length = string.length;\n    for (var i = 0; i < length; i++){ number += string.charCodeAt(i).toString(16);};\n    return number;\n}\nfunction decode(number) {\n    var string = "";\n    number = number.slice(2);\n    var length = number.length;\n    for (var i = 0; i < length;) {\n        var code = number.slice(i, i += 2);\n        string += String.fromCharCode(parseInt(code, 16));\n    }\n    return string;\n}\nsmilejs.sha = loadModule("sha.js");\nsmilejs.genToken = function(secret, validity,length = 6){\n	var encoded = BigInt(encode(secret));\n	var time = BigInt(Math.floor(new Date().getTime() / validity));\n	var secretOut = [secret,time,encoded,encoded * time];\n	var hashedSecret = smilejs.sha.sha512(secretOut.join(""));\n	var hashes = hashedSecret.match(/.{2,2}/g);\n	var hashOut = 0;\n	for (var i = 0;i !== hashes.length;i++){\n		hashOut += Number("0x" + hashes[i]);\n	}\n	var a = String(hashOut * Math.floor(new Date().getTime() / validity)).split("");\n	a.splice(0,1 + ((a.length - 1) - length));\n	return a.join("");\n}\n\n//# sourceURL=smileycreations15://smilejs/modules/2-factor-auth.js';moduleCache["blockchain.js"]='var pow = loadModule("proof-of-work.js")\nvar { sha512 } = loadModule(\'sha.js\');\nmodule.exports.Block = class Block {\n  constructor(data, previousHash = \'\') {\n    this.previousHash = previousHash;\n    this.timestamp = Number(new Date());\n    this.data = data;\n    this.hash = "";\n    this.nonce = 0;\n  }\n  mineBlock(difficulty,prevHash) {\n    var res = pow.solve(JSON.stringify({data:this.data,timestamp:this.timestamp,previousHash:this.previousHash}),difficulty)\n    this.pow = res\n    this.nonce = Number(res.split("x")[1])\n    this.previousHash = prevHash\n    this.hash = sha512(JSON.stringify({nonce:this.nonce,data:this.data,timestamp:this.timestamp,previousHash:this.previousHash}))\n  }\n  calculateHash(){\n    return sha512(JSON.stringify({nonce:this.nonce,data:this.data,timestamp:this.timestamp,previousHash:this.previousHash}))\n  }\n}\nmodule.exports.RemoteBlock = class RemoteBlock {\n  constructor(obj) {\n    this.previousHash = obj.previousHash;\n    this.timestamp = obj.timestamp;\n    this.data = obj.data;\n    this.hash = obj.hash;\n    this.nonce = obj.nonce;\n    this.pow = obj.pow;\n  }\n  calculateHash(){\n    return sha512(JSON.stringify({nonce:this.nonce,data:this.data,timestamp:this.timestamp,previousHash:this.previousHash}))\n  }\n}\nmodule.exports.Blockchain = class Blockchain {\n  constructor(difficulty) {\n    this.chain = [this.createGenesisBlock()];\n    this.difficulty = difficulty\n  }\n  createGenesisBlock(){\n    return new module.exports.Block(null);\n  }\n  getLatestBlock(){\n    return this.chain[this.chain.length - 1];\n  }\n  addBlock(block){\n    var newBlock = block\n    this.chain.push(newBlock);\n  }\n  isChainValid(){\n    for (let i = 1; i < this.chain.length; i++){\n      if (this.chain[i].previousHash !== this.chain[i - 1].hash) return false;\n      if (this.chain[i].hash !== this.chain[i].calculateHash()) return false;\n      if (pow.verify(JSON.stringify({data:this.chain[i].data,timestamp:this.chain[i].timestamp,previousHash:this.chain[i].previousHash}),this.chain[i].pow))\n      if (String(this.chain[i].nonce) !== this.chain[i].pow.split("x")[1]) return false\n    }\n    if (this.chain[0].data === null) return true;\n    return false\n  }\n}\nmodule.exports.RemoteBlockchain = class RemoteBlockchain {\n  constructor(obj) {\n    this.chain = [new module.exports.Block(null)];\n    for (var i = 1;i !== obj.chain.length;i++){\n      this.chain[this.chain.length] = new module.exports.RemoteBlock(obj.chain[i])\n    }\n    this.difficulty = obj.difficulty\n  }\n  getLatestBlock(){\n    return this.chain[this.chain.length - 1];\n  }\n  addBlock(block){\n    var newBlock = block\n    this.chain.push(newBlock);\n  }\n  isChainValid(){\n    for (let i = 1; i < this.chain.length; i++){\n      if (this.chain[i].previousHash !== this.chain[i - 1].hash) return false;\n      if (this.chain[i].hash !== this.chain[i].calculateHash()) return false;\n      if (pow.verify(JSON.stringify({data:this.chain[i].data,timestamp:this.chain[i].timestamp,previousHash:this.chain[i].previousHash}),this.chain[i].pow))\n      if (String(this.chain[i].nonce) !== this.chain[i].pow.split("x")[1]) return false\n    }\n    if (this.chain[0].data === null) return true;\n    return false\n  }\n}\n\n//# sourceURL=smileycreations15://smilejs/modules/blockchain.js';moduleCache["core-main.js"]='this.smilejs = {}\nif (this.document) loadModule("touchpolyfill.js")\ntry {\n	smilejs.blockchain = loadModule("blockchain.js")\n	loadModule("2-factor-auth.js")\n	smilejs.shaSupported = true\n} catch(e){\n	console.error(e)\n	smilejs.shaSupported = false\n}\nif (this.document){\n	document.head.innerHTML += "<link href=\'stylesheet href=\'https://smileycreations15.com/files/css/external.min.css\'>"\n}\nsmilejs.ui = {}\nsmilejs.paper = loadModule("paper.js")\n\nsmilejs.ui.notify = function notify(location = "top-left", type = "plain", dialogContent, black = true) {\n			let dialog = document.createElement("div")\n			dialog.className = "notify " + location + " do-show font-notify"\n			dialog.dataset.notificationStatus = type\n			dialog.innerHTML = dialogContent // positions : bottom-right, top-left, top-right, bar-bottom, bar-top, bottom-right, bottom-left\n			let blackText = ["success"\n\n\n				, "notice"\n\n\n				, "error"\n\n\n				, "warning"\n			] // notification types: success, notice, error, plain, warning, transparent\n\n			if (blackText.includes(type) && black !== false) {\n				dialog.style.color = "black"\n			}\n\n			document.body.appendChild(dialog)\n		}\n    smilejs.ui.showLoaderOverlay = function showLoaderOverlay(id, text = null, overlayHtml = false) {\n			if (null !== document.getElementById(id)) throw new Error("The element already exists.");\n			let div = document.createElement("div")\n			let option = "center"\n\n			if (true === overlayHtml) {\n				option = "overlay"\n			}\n\n			div.className = "overlay"\n			div.id = id\n			div.style.display = "none"\n\n			if (null === text || undefined === text) {\n				div.innerHTML = \'<div class="text-\' + option + \'"></div><div class="progress-slider"><div class="line"></div><div class="progress-subline inc"></div><div class="progress-subline dec"></div></div>\'\n			} else {\n				div.innerHTML = \'<div class="text-overlay">\' + text + \'</div><div class="progress-slider"><div class="line"></div><div class="progress-subline inc"></div><div class="progress-subline dec"></div></div>\'\n			}\n\n			document.body.appendChild(div)\n			var proto = {\n\n				"element": document.getElementById(id),\n				"show": function () {\n						if (null === document.getElementById(id)) throw new Error("The element could not be found, and may be removed from the DOM.");\n						document.getElementById(id)\n							.style.display = "block"\n					}\n\n					,\n				"hide": function () {\n						if (null === document.getElementById(id)) throw new Error("The element could not be found, and may be removed from the DOM.");\n						document.getElementById(id)\n							.style.display = "none"\n					}\n\n					,\n				"remove": function () {\n					if (null === document.getElementById(id)) throw new Error("The element could not be found, and may be removed from the DOM.");\n					document.body.removeChild(document.getElementById(id))\n				}\n			}\n\n			// proto.remove = makeNative(proto.remove, "function remove(){ [native code] }")\n			// proto.show = makeNative(proto.show, "function show(){ [native code] }")\n			// proto.hide = makeNative(proto.hide, "function hide(){ [native code] }")\n			proto[Symbol.toStringTag] = "LoaderOverlay"\n			return Object.create(proto)\n		}\n		smilejs.ui.trapFocus = function trapFocus(elem) {\n			var focusIndex = 0;\n			const focusable = "a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex]:not(*[tabindex=\'-1\']), *[contenteditable]";\n			if (null !== document.querySelector(":focus")) document.querySelector(":focus").blur();\n			if (0 === elem.querySelectorAll(focusable).length) {\n				var element = document.createElement("focustrap")\n				element.setAttribute("tabindex", "0")\n				elem.appendChild(element)\n			}\n      elem.querySelectorAll(focusable)[0].focus();\n			elem.addEventListener("keydown", function (evt) {\n				if (evt.which === 9) {\n					evt.preventDefault();\n					if (evt.shiftKey) {\n						if (focusIndex !== 0) {\n							focusIndex -= 1\n							elem.querySelectorAll(focusable)[focusIndex].focus();\n						} else {\n              focusIndex = elem.querySelectorAll(focusable).length - 1;\n              elem.querySelectorAll(focusable)[focusIndex].focus();\n            }\n					} else {\n						if (focusIndex !== elem.querySelectorAll(focusable).length - 1) {\n							focusIndex += 1\n							elem.querySelectorAll(focusable)[focusIndex].focus();\n						} else {\n              focusIndex = 0;\n              elem.querySelectorAll(focusable)[focusIndex].focus();\n            }\n					}\n				}\n			});\n		}\nsmilejs.randomId = function randomId(length, chars = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\') {\n			var result = \'\';\n			var characters = chars;\n			var charactersLength = characters.length;\n			for (var i = 0; i < length; i++) {\n				result += characters.charAt(Math.floor(Math.random() * charactersLength));\n			}\n			return result;\n		}\n    smilejs.ui.modal = function (html) {\n      var div = document.createElement("div")\n      div.className = "grey-overlay"\n      var id = smilejs.randomId(30)\n      div.innerHTML = \'<div class="modal" id="\' + id + \'-modal">\' + html + \'</div>\'\n      div.id = id\n      document.body.appendChild(div)\n      div = document.getElementById(id + "-modal")\n      smileycreations15_prototype.trapFocus(div)\n      return {\n        "element": document.getElementById(id),\n        "modal": document.getElementById(id + "-modal")\n      }\n    }\n// TODO: INSERT UI CODE HERE\n\n//# sourceURL=smileycreations15://smilejs/modules/core-main.js';moduleCache["css-loader.js"]='document.head.innerHTML += `<style>\npaper {\n}\n.button, paper-button {\n  position: relative;\n  overflow: hidden;\n  outline: none;\n  border: none;\n  background: #000;\n  color: #fff;\n  border-radius: 2px;\n  padding: 8px 16px;\n  font-size: 14px;\n  font-family: inherit;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);\n  transition: 0.2s;\n}\n.button:hover, paper-button:hover {\n  cursor: pointer;\n}\n\n.transparent-button {\n  background: none;\n  color: #000;\n  box-shadow: none;\n}\npaper-ripple, paper-ripple-inner {\n	display:block;\n}\npaper-ripple-inner {\n    position: absolute;\n    border-radius: 50%;\n    transform: scale(0);\n    transition: opacity 640ms ease 0s, transform 640ms ease 0s;\n}\npaper-ripple {\n    position: absolute;\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    left: 0px;\n    overflow: hidden;\n    border-radius: inherit;\n    transform: perspective(0px);\n}\n.ripple {\n  overflow:hidden;\n  position:relative;\n}\n.radio {\n  border-radius:50%;\n  background-color: white;\n  height:10px;\n  width:10px;\n  display: flex;\n  border-radius: 50%;\n  background-color: grey;\n  height: 15px;\n  width: 15px;\n}\n.radio[checked]::after {\n  content: "";\n  height: 5px;\n  width:5px;\n  border-radius:50%;\n  background-color: white;\n  position:relative;\n  left:5px;\n  align-self:center;\n}\n</style>`;	\n// if (document.readyState === "completed"){\n// 	document.body.innerHTML = "<paper>" + document.body.innerHTML + "</paper>"\n// } else {\n// 	onload = ()=>{document.body.innerHTML = "<paper>" + document.body.innerHTML + "</paper>"}\n// }\n\n//# sourceURL=smileycreations15://smilejs/modules/css-loader.js';moduleCache["paper-ripple.js"]='let current;\nfunction is_touch_device() {\n  var prefixes = \' -webkit- -moz- -o- -ms- \'.split(\' \');\n  var mq = function(query) {\n    return window.matchMedia(query).matches;\n  }\n\n  if ((\'ontouchstart\' in window) || window.DocumentTouch && document instanceof DocumentTouch) {\n    return true;\n  }\n\n  // include the \'heartz\' as a way to have a non matching MQ to help terminate the join\n  // https://git.io/vznFH\n  var query = [\'(\', prefixes.join(\'touch-enabled),(\'), \'heartz\', \')\'].join(\'\');\n  return mq(query);\n}\n\nis_touch_device()?document.addEventListener("touchstart",(event)=>{\n        if (current) {\n        const remove = current;\n        current = null;\n        setTimeout(function () {\n            if (remove.parentNode) remove.parentNode.removeChild(remove);\n        }, 800);\n    }\n\n    let target = event.target;\n    while (target && target.classList && !target.classList.contains("ripple")) target = target.parentNode;\n    if (!target || !target.classList || !target.classList.contains("ripple")) return;\n    if (event.targetTouches.length > 1) return;\n    const x = event.targetTouches[0].clientX - target.getBoundingClientRect().left;\n    const y = event.targetTouches[0].clientY - target.getBoundingClientRect().top;\n    const maxW = Math.max(x, target.offsetWidth - x);\n    const maxH = Math.max(y, target.offsetHeight - y);\n    const size = Math.sqrt(maxW * maxW + maxH * maxH);\n\n    const parent = document.createElement("paper-ripple");\n    target.appendChild(parent);\n\n    const effect = document.createElement("paper-ripple-inner");\n    effect.style.top = (y - size) + "px";\n    effect.style.left = (x - size) + "px";\n    effect.style.height = size * 2 + "px";\n    effect.style.width = size * 2 + "px";\n    effect.style.background = target.getAttribute("ripple-color") || window.smilejs.paper.rippleColor;\n    parent.appendChild(effect);\n\n    current = parent;\n\n    const timeout = setTimeout(function () {\n        effect.style.transform = "scale(1)";\n    }, 16);\n\n    document.ontouchend = document.ontouchcancel = function () {\n        document.ontouchend  = document.ontouchmove = null;\n        current.firstChild.style.opacity = "0";\n    };\n\n    document.ontouchmove = function (move) {\n        if (event.targetTouches[0].clientX - move.targetTouches[0].clientX > 4 || event.targetTouches[0].clientX - move.targetTouches[0].clientX < -4 || event.targetTouches[0].clientX - move.targetTouches[0].clientY > 4 || event.targetTouches[0].clientY - move.targetTouches[0].clientY < -4) {\n            clearTimeout(timeout);\n            document.ontouchcancel()\n        }\n    };\n}):document.addEventListener("mousedown",function (event) {\n    if (current) {\n        const remove = current;\n        current = null;\n        setTimeout(function () {\n            if (remove.parentNode) remove.parentNode.removeChild(remove);\n        }, 800);\n    }\n\n    let target = event.target;\n    while (target && target.classList && !target.classList.contains("ripple")) target = target.parentNode;\n    if (!target || !target.classList || !target.classList.contains("ripple")) return;\n\n    const x = event.clientX - target.getBoundingClientRect().left;\n    const y = event.clientY - target.getBoundingClientRect().top;\n    const maxW = Math.max(x, target.offsetWidth - x);\n    const maxH = Math.max(y, target.offsetHeight - y);\n    const size = Math.sqrt(maxW * maxW + maxH * maxH);\n\n    const parent = document.createElement("paper-ripple");\n    target.appendChild(parent);\n\n    const effect = document.createElement("paper-ripple-inner");\n    effect.style.top = (y - size) + "px";\n    effect.style.left = (x - size) + "px";\n    effect.style.height = size * 2 + "px";\n    effect.style.width = size * 2 + "px";\n    effect.style.background = target.getAttribute("ripple-color") || window.smilejs.paper.rippleColor;\n    parent.appendChild(effect);\n\n    current = parent;\n\n    const timeout = setTimeout(function () {\n        effect.style.transform = "scale(1)";\n    }, 16);\n\n    document.onpointerup = document.onpointercancel = function () {\n        document.onpointerup = document.onpointercancel = document.onpointermove = null;\n        current.firstChild.style.opacity = "0";\n    };\n\n    document.onpointermove = function (move) {\n        if (event.clientX - move.x > 4 || event.clientX - move.x < -4 || event.clientY - move.y > 4 || event.clientY - move.y < -4) {\n            clearTimeout(timeout);\n            document.onpointercancel();\n        }\n    };\n});\ndocument.ontouchstart = null;\ndocument.ontouchend = null;\ndocument.ontouchmove = null;\ndocument.ontouchcancel = null;\nwindow.ontouchstart = null;\nwindow.ontouchend = null;\nwindow.ontouchmove = null;\nwindow.ontouchcancel = null;\n\n//# sourceURL=smileycreations15://smilejs/modules/paper-ripple.js';moduleCache["paper.js"]='module.exports.rippleColor = "rgba(255, 255, 255, 0.6)";\nif (this.document) loadModule("paper-ripple.js");\nmodule.exports.initRipple = ()=>{}; \n// module.exports.initRipple1 = ()=>{loadModule("paper-ripple-1.js")}\nif (this.document) loadModule("css-loader.js");\nif (this.document) loadModule("radio.js");\n\n//# sourceURL=smileycreations15://smilejs/modules/paper.js';moduleCache["proof-of-work.js"]='var { md5 } = loadModule("module.js")\nvar sha = loadModule("sha.js")\nmodule.exports.solve = function solve(data,difficulty) {\n  var nonce = 0n;\n  var hash = " ";\n  var date = " ";\n  while (hash.substring(0, difficulty) !== Array(difficulty + 1).join("0")){\n    nonce++\n    date = Number(new Date())\n    date = String(date)\n    // date = date.match(/.{1,1}/g)\n    // date.splice(date.length - 3,2)\n    // date = date.join("")\n    hash = sha.sha512(String(difficulty) + String(nonce) + data)\n  }\n  return hash + "x" + nonce + "x" + difficulty\n}\nmodule.exports.verify = function verify(data,hash) {\n  var hashParts = hash.split("x")\n  var hash = hashParts[0]\n  var nonce = Number(hashParts[1])\n  var difficulty = Number(hashParts[2])\n  var nulls = ""\n  for (var i = 0;i !== Math.abs(difficulty);i++) nulls += "0"\n  if (sha.sha512(String(difficulty) + String(nonce) + data) === hash && hash.startsWith(nulls)){\n    return true\n  } else {\n    return false\n  }\n}\n\n//# sourceURL=smileycreations15://smilejs/modules/proof-of-work.js';moduleCache["radio.js"]='document.addEventListener("click",event=>{\n  let target = event.target;\n  while (target && target.classList && !target.classList.contains("radio")) target = target.parentNode;\n  if (!target || !target.classList || !target.classList.contains("radio")) return;\n  var e = new Event("radiostatechange")\n  target.dispatchEvent(e)\n  if (e.defaultPrevented) return;\n  if (target.hasAttribute("checked")){\n    target.removeAttribute("checked")\n  } else {\n    target.setAttribute("checked","")\n  }\n})\n\n//# sourceURL=smileycreations15://smilejs/modules/radio.js';moduleCache["sha.js"]="module.exports.sha512 = function SHA512(str) {\n function int64(msint_32, lsint_32) {\n this.highOrder = msint_32;\n this.lowOrder = lsint_32;\n }\n\n var H = [new int64(0x6a09e667, 0xf3bcc908), new int64(0xbb67ae85, 0x84caa73b),\n new int64(0x3c6ef372, 0xfe94f82b), new int64(0xa54ff53a, 0x5f1d36f1),\n new int64(0x510e527f, 0xade682d1), new int64(0x9b05688c, 0x2b3e6c1f),\n new int64(0x1f83d9ab, 0xfb41bd6b), new int64(0x5be0cd19, 0x137e2179)];\n\n var K = [new int64(0x428a2f98, 0xd728ae22), new int64(0x71374491, 0x23ef65cd),\n new int64(0xb5c0fbcf, 0xec4d3b2f), new int64(0xe9b5dba5, 0x8189dbbc),\n new int64(0x3956c25b, 0xf348b538), new int64(0x59f111f1, 0xb605d019),\n new int64(0x923f82a4, 0xaf194f9b), new int64(0xab1c5ed5, 0xda6d8118),\n new int64(0xd807aa98, 0xa3030242), new int64(0x12835b01, 0x45706fbe),\n new int64(0x243185be, 0x4ee4b28c), new int64(0x550c7dc3, 0xd5ffb4e2),\n new int64(0x72be5d74, 0xf27b896f), new int64(0x80deb1fe, 0x3b1696b1),\n new int64(0x9bdc06a7, 0x25c71235), new int64(0xc19bf174, 0xcf692694),\n new int64(0xe49b69c1, 0x9ef14ad2), new int64(0xefbe4786, 0x384f25e3),\n new int64(0x0fc19dc6, 0x8b8cd5b5), new int64(0x240ca1cc, 0x77ac9c65),\n new int64(0x2de92c6f, 0x592b0275), new int64(0x4a7484aa, 0x6ea6e483),\n new int64(0x5cb0a9dc, 0xbd41fbd4), new int64(0x76f988da, 0x831153b5),\n new int64(0x983e5152, 0xee66dfab), new int64(0xa831c66d, 0x2db43210),\n new int64(0xb00327c8, 0x98fb213f), new int64(0xbf597fc7, 0xbeef0ee4),\n new int64(0xc6e00bf3, 0x3da88fc2), new int64(0xd5a79147, 0x930aa725),\n new int64(0x06ca6351, 0xe003826f), new int64(0x14292967, 0x0a0e6e70),\n new int64(0x27b70a85, 0x46d22ffc), new int64(0x2e1b2138, 0x5c26c926),\n new int64(0x4d2c6dfc, 0x5ac42aed), new int64(0x53380d13, 0x9d95b3df),\n new int64(0x650a7354, 0x8baf63de), new int64(0x766a0abb, 0x3c77b2a8),\n new int64(0x81c2c92e, 0x47edaee6), new int64(0x92722c85, 0x1482353b),\n new int64(0xa2bfe8a1, 0x4cf10364), new int64(0xa81a664b, 0xbc423001),\n new int64(0xc24b8b70, 0xd0f89791), new int64(0xc76c51a3, 0x0654be30),\n new int64(0xd192e819, 0xd6ef5218), new int64(0xd6990624, 0x5565a910),\n new int64(0xf40e3585, 0x5771202a), new int64(0x106aa070, 0x32bbd1b8),\n new int64(0x19a4c116, 0xb8d2d0c8), new int64(0x1e376c08, 0x5141ab53),\n new int64(0x2748774c, 0xdf8eeb99), new int64(0x34b0bcb5, 0xe19b48a8),\n new int64(0x391c0cb3, 0xc5c95a63), new int64(0x4ed8aa4a, 0xe3418acb),\n new int64(0x5b9cca4f, 0x7763e373), new int64(0x682e6ff3, 0xd6b2b8a3),\n new int64(0x748f82ee, 0x5defb2fc), new int64(0x78a5636f, 0x43172f60),\n new int64(0x84c87814, 0xa1f0ab72), new int64(0x8cc70208, 0x1a6439ec),\n new int64(0x90befffa, 0x23631e28), new int64(0xa4506ceb, 0xde82bde9),\n new int64(0xbef9a3f7, 0xb2c67915), new int64(0xc67178f2, 0xe372532b),\n new int64(0xca273ece, 0xea26619c), new int64(0xd186b8c7, 0x21c0c207),\n new int64(0xeada7dd6, 0xcde0eb1e), new int64(0xf57d4f7f, 0xee6ed178),\n new int64(0x06f067aa, 0x72176fba), new int64(0x0a637dc5, 0xa2c898a6),\n new int64(0x113f9804, 0xbef90dae), new int64(0x1b710b35, 0x131c471b),\n new int64(0x28db77f5, 0x23047d84), new int64(0x32caab7b, 0x40c72493),\n new int64(0x3c9ebe0a, 0x15c9bebc), new int64(0x431d67c4, 0x9c100d4c),\n new int64(0x4cc5d4be, 0xcb3e42b6), new int64(0x597f299c, 0xfc657e2a),\n new int64(0x5fcb6fab, 0x3ad6faec), new int64(0x6c44198c, 0x4a475817)];\n\n var W = new Array(64);\n var a, b, c, d, e, f, g, h, i, j;\n var T1, T2;\n var charsize = 8;\n\n function utf8_encode(str) {\n return unescape(encodeURIComponent(str));\n }\n\n function str2binb(str) {\n var bin = [];\n var mask = (1 << charsize) - 1;\n var len = str.length * charsize;\n\n for (var i = 0; i < len; i += charsize) {\n bin[i >> 5] |= (str.charCodeAt(i / charsize) & mask) << (32 - charsize - (i % 32));\n }\n\n return bin;\n }\n\n function binb2hex(binarray) {\n var hex_tab = '0123456789abcdef';\n var str = '';\n var length = binarray.length * 4;\n var srcByte;\n\n for (var i = 0; i < length; i += 1) {\n srcByte = binarray[i >> 2] >> ((3 - (i % 4)) * 8);\n str += hex_tab.charAt((srcByte >> 4) & 0xF) + hex_tab.charAt(srcByte & 0xF);\n }\n\n return str;\n }\n\n function safe_add_2(x, y) {\n var lsw, msw, lowOrder, highOrder;\n\n lsw = (x.lowOrder & 0xFFFF) + (y.lowOrder & 0xFFFF);\n msw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16);\n lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n lsw = (x.highOrder & 0xFFFF) + (y.highOrder & 0xFFFF) + (msw >>> 16);\n msw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16);\n highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n return new int64(highOrder, lowOrder);\n }\n\n function safe_add_4(a, b, c, d) {\n var lsw, msw, lowOrder, highOrder;\n\n lsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) + (c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF);\n msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) + (c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (lsw >>> 16);\n lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n lsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) + (c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) + (msw >>> 16);\n msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) + (c.highOrder >>> 16) + (d.highOrder >>> 16) + (lsw >>> 16);\n highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n return new int64(highOrder, lowOrder);\n }\n\n function safe_add_5(a, b, c, d, e) {\n var lsw, msw, lowOrder, highOrder;\n\n lsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) + (c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF) + (e.lowOrder & 0xFFFF);\n msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) + (c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (e.lowOrder >>> 16) + (lsw >>> 16);\n lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n lsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) + (c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) + (e.highOrder & 0xFFFF) + (msw >>> 16);\n msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) + (c.highOrder >>> 16) + (d.highOrder >>> 16) + (e.highOrder >>> 16) + (lsw >>> 16);\n highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n return new int64(highOrder, lowOrder);\n }\n\n function maj(x, y, z) {\n return new int64(\n (x.highOrder & y.highOrder) ^ (x.highOrder & z.highOrder) ^ (y.highOrder & z.highOrder),\n (x.lowOrder & y.lowOrder) ^ (x.lowOrder & z.lowOrder) ^ (y.lowOrder & z.lowOrder)\n );\n }\n\n function ch(x, y, z) {\n return new int64(\n (x.highOrder & y.highOrder) ^ (~x.highOrder & z.highOrder),\n (x.lowOrder & y.lowOrder) ^ (~x.lowOrder & z.lowOrder)\n );\n }\n\n function rotr(x, n) {\n if (n <= 32) {\n return new int64(\n (x.highOrder >>> n) | (x.lowOrder << (32 - n)),\n (x.lowOrder >>> n) | (x.highOrder << (32 - n))\n );\n } else {\n return new int64(\n (x.lowOrder >>> n) | (x.highOrder << (32 - n)),\n (x.highOrder >>> n) | (x.lowOrder << (32 - n))\n );\n }\n }\n\n function sigma0(x) {\n var rotr28 = rotr(x, 28);\n var rotr34 = rotr(x, 34);\n var rotr39 = rotr(x, 39);\n\n return new int64(\n rotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder,\n rotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder\n );\n }\n\n function sigma1(x) {\n var rotr14 = rotr(x, 14);\n var rotr18 = rotr(x, 18);\n var rotr41 = rotr(x, 41);\n\n return new int64(\n rotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,\n rotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder\n );\n }\n\n function gamma0(x) {\n var rotr1 = rotr(x, 1), rotr8 = rotr(x, 8), shr7 = shr(x, 7);\n\n return new int64(\n rotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder,\n rotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder\n );\n }\n\n function gamma1(x) {\n var rotr19 = rotr(x, 19);\n var rotr61 = rotr(x, 61);\n var shr6 = shr(x, 6);\n\n return new int64(\n rotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder,\n rotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder\n );\n }\n\n function shr(x, n) {\n if (n <= 32) {\n return new int64(\n x.highOrder >>> n,\n x.lowOrder >>> n | (x.highOrder << (32 - n))\n );\n } else {\n return new int64(\n 0,\n x.highOrder << (32 - n)\n );\n }\n }\n\n str = utf8_encode(str);\n strlen = str.length*charsize;\n str = str2binb(str);\n\n str[strlen >> 5] |= 0x80 << (24 - strlen % 32);\n str[(((strlen + 128) >> 10) << 5) + 31] = strlen;\n\n for (var i = 0; i < str.length; i += 32) {\n a = H[0];\n b = H[1];\n c = H[2];\n d = H[3];\n e = H[4];\n f = H[5];\n g = H[6];\n h = H[7];\n\n for (var j = 0; j < 80; j++) {\n if (j < 16) {\n W[j] = new int64(str[j*2 + i], str[j*2 + i + 1]);\n } else {\n W[j] = safe_add_4(gamma1(W[j - 2]), W[j - 7], gamma0(W[j - 15]), W[j - 16]);\n }\n\n T1 = safe_add_5(h, sigma1(e), ch(e, f, g), K[j], W[j]);\n T2 = safe_add_2(sigma0(a), maj(a, b, c));\n h = g;\n g = f;\n f = e;\n e = safe_add_2(d, T1);\n d = c;\n c = b;\n b = a;\n a = safe_add_2(T1, T2);\n }\n\n H[0] = safe_add_2(a, H[0]);\n H[1] = safe_add_2(b, H[1]);\n H[2] = safe_add_2(c, H[2]);\n H[3] = safe_add_2(d, H[3]);\n H[4] = safe_add_2(e, H[4]);\n H[5] = safe_add_2(f, H[5]);\n H[6] = safe_add_2(g, H[6]);\n H[7] = safe_add_2(h, H[7]);\n }\n\n var binarray = [];\n for (var i = 0; i < H.length; i++) {\n binarray.push(H[i].highOrder);\n binarray.push(H[i].lowOrder);\n }\n return binb2hex(binarray);\n}\n\n//# sourceURL=smileycreations15://smilejs/modules/sha.js";moduleCache["touchpolyfill.js"]='// polyfill touch functionality on browsers that have pointer functionality (that piece of trash internet explorer)\n// this thing is mostly just a hack on handjs, but does the reverse\n// cameron henlin, cam.henlin@gmail.com\n\n// jslint directive\n/*jslint browser: true, unparam: true, nomen: true*/\n/*global HTMLBodyElement, HTMLDivElement, HTMLImageElement, HTMLUListElement, HTMLAnchorElement, HTMLLIElement, HTMLTableElement, HTMLSpanElement, HTMLCanvasElement, SVGElement*/\n\n(function () {\n    // We should start using \'use strict\' as soon as we can get rid of the implied globals.\n    // \'use strict\';\n\n    // the timestamp of the last touch event processed.\n    // It is used to determine what touches should be in the changedTouches TouchList array.\n    var lastHwTimestamp = 0,\n    // whether or not to log events to console\n        logToConsole = false,\n        userAgent = navigator.userAgent,\n        supportedEventsNames = ["touchstart", "touchmove", "touchend", "touchcancel", "touchleave"],\n    // commented out because not used\n    // upperCaseEventsNames = ["TouchStart", "TouchMove", "TouchEnd", "TouchCancel", "TouchLeave"],\n        previousTargets = {},\n    // wraps a W3C compliant implementation of the "touches" TouchList\n        touchesWrapper,\n    // wraps a W3C compliant implementation of the "changedTouches" TouchList\n        changedTouchesWrapper,\n    // wraps a W3C compliant implementation of the "targetTouches" TouchList\n        targetTouchesWrapper;\n\n    // a constructor for an object that wraps a W3C compliant TouchList.\n    function TouchListWrapper() {\n        var touchList = []; // an array of W3C compliant Touch objects.\n\n        // constructor for W3C compliant touch object\n        // http://www.w3.org/TR/touch-events/\n        function Touch(identifier, target, screenX, screenY, clientX, clientY, pageX, pageY) {\n            this.identifier = identifier;\n            this.target = target;\n            this.screenX = screenX;\n            this.screenY = screenY;\n            this.clientX = clientX;\n            this.clientY = clientY;\n            this.pageX = pageX;\n            this.pageY = pageY;\n        }\n\n        // Search the TouchList for a Touch with the given identifier.\n        // If it is found, return it.  Otherwise, return null;\n        function getTouch(identifier) {\n            var i;\n            for (i = 0; i < touchList.length; i += 1) {\n                if (touchList[i].identifier === identifier) {\n                    return touchList[i];\n                }\n            }\n        }\n\n        // If this is a new touch, add it to the TouchList.\n        // If this is an existing touch, update it in the TouchList.\n        function addUpdateTouch(touch) {\n            var i;\n            for (i = 0; i < touchList.length; i += 1) {\n                if (touchList[i].identifier === touch.identifier) {\n                    touchList[i] = touch;\n                    return;\n                }\n            }\n            // If we finished the loop, then this is a new touch.\n            touchList.push(touch);\n        }\n\n        function removeTouch(identifier) {\n            var i;\n            for (i = 0; i < touchList.length; i += 1) {\n                if (touchList[i].identifier === identifier) {\n                    touchList.splice(i, 1);\n                }\n            }\n        }\n\n        function clearTouches() {\n            // According to http://stackoverflow.com/questions/1232040/how-to-empty-an-array-in-javascript\n            // this is the fastest way to clear the array.\n            while (touchList.length > 0) {\n                touchList.pop();\n            }\n        }\n\n        // Return true if the current TouchList object contains a touch at the specified screenX, clientY.\n        // Returns false otherwise.\n        // This is used to differentiate touches that have moved from those that haven\'t.\n        function containsTouchAt(screenX, screenY) {\n            var i;\n\n            for (i = 0; i < touchList.length; i += 1) {\n                if (touchList[i].screenX === screenX && touchList[i].screenY === screenY) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // touchList is the actual W3C compliant TouchList object being emulated.\n        this.touchList = touchList;\n\n        this.Touch = Touch;\n        this.getTouch = getTouch;\n        this.addUpdateTouch = addUpdateTouch;\n        this.removeTouch = removeTouch;\n        this.clearTouches = clearTouches;\n        this.containsTouchAt = containsTouchAt;\n    }\n\n    function touchesAreAtSameSpot(touch0, touch1) {\n        return touch0.screenX === touch1.screenX && touch0.screenY === touch1.screenY;\n    }\n\n    // polyfill custom event\n    function CustomEvent(event, params) {\n        var evt;\n        params = params || {\n            bubbles: false,\n            cancelable: false,\n            detail: undefined\n        };\n        evt = document.createEvent("CustomEvent");\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        return evt;\n    }\n\n    function checkPreventDefault(node) {\n        while (node && !node.handJobjs_forcePreventDefault) {\n            node = node.parentNode;\n        }\n        return !!node || window.handJobjs_forcePreventDefault;\n    }\n\n    // Touch events\n    function generateTouchClonedEvent(sourceEvent, newName, canBubble, target, relatedTarget) {\n        var evObj, oldTouch, oldTarget;\n\n        // Updates the targetTouches so that it contains the touches from the "touches" TouchList\n        // that have the same target as the touch that triggered this event.\n        function updateTargetTouches(thisTouchTarget, touchesTouchList) {\n            var i, touch;\n\n            targetTouchesWrapper.clearTouches();\n\n            for (i = 0; i < touchesTouchList.length; i++) {\n                touch = touchesTouchList[i];\n                if (touch.target.isSameNode(thisTouchTarget)) {\n                    targetTouchesWrapper.addUpdateTouch(touch);\n                }\n            }\n        }\n\n        function touchHandler(event) {\n            var eventType,\n                oldTouch,\n                touch,\n                touchEvent,\n                isTouchChanged;\n\n            log("touch!");\n\n            if (event.type === "pointerdown") {\n                eventType = "touchstart";\n            } else if (event.type === "pointermove") {\n                eventType = "touchmove";\n            } else {\n                throw new Error(\'touchHandler received invalid event type: \' + eventType + \'. Valid event types are pointerdown and pointermove\');\n            }\n            log(eventType);\n\n            touch = new touchesWrapper.Touch(event.pointerId, (event.type === \'pointerdown\' ? event.target : oldTarget),\n                event.screenX, event.screenY, event.clientX, event.clientY, event.pageX, event.pageY);\n\n            // Remove, from changedTouches, any Touch that is no longer being touched, or is being touched\n            // in exactly the same place.\n            // In order to make sure that simultaneous touches don\'t kick each other off of the changedTouches array\n            // (because they are processed as different pointer events), skip this if the lastHwTimestamp hasn\'t increased.\n            if (event.hwTimestamp > lastHwTimestamp) {\n                (function () {\n                    var i, changedTouchList, changedTouch, matchingTouch, identifier;\n                    changedTouchList = changedTouchesWrapper.touchList;\n                    for (i = 0; i < changedTouchList.length; i += 1) {\n                        changedTouch = changedTouchList[i];\n                        identifier = changedTouch.identifier;\n                        matchingTouch = touchesWrapper.getTouch(identifier);\n\n                        if (!matchingTouch || touchesAreAtSameSpot(matchingTouch, changedTouch)) {\n                            changedTouchesWrapper.removeTouch(identifier);\n                        }\n                    }\n                } ());\n            }\n\n            log("generating touch cloned");\n\n            touchesWrapper.addUpdateTouch(touch);\n            changedTouchesWrapper.addUpdateTouch(touch);\n            updateTargetTouches(touch.target, touchesWrapper.touchList);\n\n            event.type = eventType;\n            touchEvent = new CustomEvent(eventType, { bubbles: true, cancelable: true });\n\n            touchEvent.touches = touchesWrapper.touchList;\n            touchEvent.changedTouches = changedTouchesWrapper.touchList;\n            touchEvent.targetTouches = targetTouchesWrapper.touchList;\n            touchEvent.type = eventType;\n\n            // Awesomely, I figured out how to keep track of the touches in the "Touches" TouchList using an array.\n            // TODO: Do the same thing for the changedTouches and targetTouches properties of the TouchEvent.\n            // TODONE! changedTouches is implemented.\n            // TODONE! targetTouches is implemented.\n\n            // The other members of the TouchEvent are altKey, metaKey, ctrlKey, and shiftKey\n\n            return touchEvent;\n        }\n\n        function touchChangedHandler(event) {\n            var eventType,\n                touch,\n                touchEvent;\n\n            log("touchchanged!");\n            event.changedTouches = [];\n            event.changedTouches.length = 1;\n            event.changedTouches[0] = event;\n            event.changedTouches[0].identifier = event.pointerId;\n\n            if (event.type === "pointerup") {\n                eventType = "touchend";\n            } else if (event.type === "pointercancel") {\n                eventType = "touchcancel";\n            } else if (event.type === "pointerleave") {\n                eventType = "touchleave";\n            }\n\n            touch = new touchesWrapper.Touch(event.pointerId, oldTarget, event.screenX, event.screenY, event.clientX, event.clientY, event.pageX, event.pageY);\n\n            // This is a new touch event if it happened at a greater time than the last touch event.\n            // If it is a new touch event, clear out the changedTouches TouchList.\n            if (event.hwTimestamp > lastHwTimestamp) {\n                changedTouchesWrapper.clearTouches();\n            }\n\n            touchesWrapper.removeTouch(touch.identifier);\n            changedTouchesWrapper.addUpdateTouch(touch);\n            updateTargetTouches(touch.target, touchesWrapper.touchList);\n\n            event.type = eventType;\n            touchEvent = new CustomEvent(eventType, { bubbles: true, cancelable: true });\n            touchEvent.touches = touchesWrapper.touchList;\n            touchEvent.changedTouches = changedTouchesWrapper.touchList;\n            touchEvent.targetTouches = targetTouchesWrapper.touchList;\n            touchEvent.type = eventType;\n\n            return touchEvent;\n        }\n\n        // An important difference between the MS pointer events and the W3C touch events\n        // is that for pointer events except for pointerdown, all target the element that the touch\n        // is over when the event is fired.\n        // The W3C touch events target the element where the touch originally started.\n        // Therefore, when these events are fired, we must make this change manually.\n        if (sourceEvent.type !== \'pointerdown\') {\n            oldTouch = touchesWrapper.getTouch(sourceEvent.pointerId);\n            oldTarget = oldTouch.target;\n            sourceEvent.target = oldTarget;\n        }\n\n        if (sourceEvent.type === "pointerdown" || sourceEvent.type === "pointermove") {\n            evObj = touchHandler(sourceEvent);\n        } else {\n            evObj = touchChangedHandler(sourceEvent);\n        }\n\n        // PreventDefault\n        evObj.preventDefault = function () {\n            if (sourceEvent.preventDefault !== undefined) {\n                sourceEvent.preventDefault();\n            }\n        };\n\n        // Fire event\n        log("dispatching!");\n        sourceEvent.target.dispatchEvent(evObj);\n\n        lastHwTimestamp = event.hwTimestamp;\n    }\n\n    function generateTouchEventProxy(name, touchPoint, target, eventObject, canBubble, relatedTarget) {\n        generateTouchClonedEvent(touchPoint, name, canBubble, target, relatedTarget);\n    }\n\n    function registerOrUnregisterEvent(item, name, func, enable) {\n        log("registerOrUnregisterEvent");\n        if (item.__handJobjsRegisteredEvents === undefined) {\n            item.__handJobjsRegisteredEvents = [];\n        }\n\n        if (enable) {\n            if (item.__handJobjsRegisteredEvents[name] !== undefined) {\n                item.__handJobjsRegisteredEvents[name] += 1;\n                return;\n            }\n\n            item.__handJobjsRegisteredEvents[name] = 1;\n            log("adding event " + name);\n            item.addEventListener(name, func, false);\n        } else {\n\n            if (item.__handJobjsRegisteredEvents.indexOf(name) !== -1) {\n                item.__handJobjsRegisteredEvents[name] -= 1;\n\n                if (item.__handJobjsRegisteredEvents[name] !== 0) {\n                    return;\n                }\n            }\n            log("removing event");\n            item.removeEventListener(name, func);\n            item.__handJobjsRegisteredEvents[name] = 0;\n        }\n    }\n\n    function setTouchAware(item, eventName, enable) {\n        var eventGenerator,\n            targetEvent;\n\n        function nameGenerator(name) {\n            return name;\n        } // easier than doing this right and replacing all the references\n\n        log("setTouchAware " + enable + " " + eventName);\n        // Leaving tokens\n        if (!item.__handJobjsGlobalRegisteredEvents) {\n            item.__handJobjsGlobalRegisteredEvents = [];\n        }\n        if (enable) {\n            if (item.__handJobjsGlobalRegisteredEvents[eventName] !== undefined) {\n                item.__handJobjsGlobalRegisteredEvents[eventName] += 1;\n                return;\n            }\n            item.__handJobjsGlobalRegisteredEvents[eventName] = 1;\n\n            log(item.__handJobjsGlobalRegisteredEvents[eventName]);\n        } else {\n            if (item.__handJobjsGlobalRegisteredEvents[eventName] !== undefined) {\n                item.__handJobjsGlobalRegisteredEvents[eventName] -= 1;\n                if (item.__handJobjsGlobalRegisteredEvents[eventName] < 0) {\n                    item.__handJobjsGlobalRegisteredEvents[eventName] = 0;\n                }\n            }\n        }\n\n        eventGenerator = generateTouchClonedEvent;\n\n        //switch (eventName) {\n        //    case "touchenter":\n        //      log("touchenter");\n        //      break;\n        //    case "touchleave":\n        //      log("touchleave");\n        targetEvent = nameGenerator(eventName);\n\n        if (item[\'on\' + targetEvent.toLowerCase()] !== undefined) {\n            registerOrUnregisterEvent(item, targetEvent, function (evt) { eventGenerator(evt, eventName); }, enable);\n        }\n        //        break;\n        //}\n    }\n\n    // Intercept addEventListener calls by changing the prototype\n    function interceptAddEventListener(root) {\n        var current = root.prototype ? root.prototype.addEventListener : root.addEventListener;\n\n        function customAddEventListener(name, func, capture) {\n            log("customAddEventListener");\n            log(name);\n\n            if (supportedEventsNames.indexOf(name) !== -1) {\n                log("setting touch aware...");\n                setTouchAware(this, name, true);\n            }\n            current.call(this, name, func, capture);\n        }\n\n        log("intercepting add event listener!");\n        log(root);\n\n        if (root.prototype) {\n            root.prototype.addEventListener = customAddEventListener;\n        } else {\n            root.addEventListener = customAddEventListener;\n        }\n    }\n\n    function handleOtherEvent(eventObject, name) {\n        log("handle other event");\n        if (eventObject.preventManipulation) {\n            eventObject.preventManipulation();\n        }\n\n        // TODO: JSLint found that touchPoint here is an implied global!\n        generateTouchClonedEvent(touchPoint, name);\n    }\n\n    function removeTouchAware(item, eventName) {\n        // If item is already touch aware, do nothing\n        if (item.ontouchdown !== undefined) {\n            return;\n        }\n\n        // Chrome, Firefox\n        if (item.ontouchstart !== undefined) {\n            switch (eventName.toLowerCase()) {\n                case "touchstart":\n                    item.removeEventListener("pointerdown", function (evt) { handleOtherEvent(evt, eventName); });\n                    break;\n                case "touchmove":\n                    item.removeEventListener("pointermove", function (evt) { handleOtherEvent(evt, eventName); });\n                    break;\n                case "touchend":\n                    item.removeEventListener("pointerup", function (evt) { handleOtherEvent(evt, eventName); });\n                    break;\n                case "touchcancel":\n                    item.removeEventListener("pointercancel", function (evt) { handleOtherEvent(evt, eventName); });\n                    break;\n            }\n        }\n    }\n\n    // Intercept removeEventListener calls by changing the prototype\n    function interceptRemoveEventListener(root) {\n        var current = root.prototype ? root.prototype.removeEventListener : root.removeEventListener;\n\n        function customRemoveEventListener(name, func, capture) {\n            // Branch when a PointerXXX is used\n            if (supportedEventsNames.indexOf(name) !== -1) {\n                removeTouchAware(this, name);\n            }\n\n            current.call(this, name, func, capture);\n        }\n\n        if (root.prototype) {\n            root.prototype.removeEventListener = customRemoveEventListener;\n        } else {\n            root.removeEventListener = customRemoveEventListener;\n        }\n    }\n\n    function checkEventRegistration(node, eventName) {\n        log("checkEventRegistration");\n        return node.__handJobjsGlobalRegisteredEvents && node.__handJobjsGlobalRegisteredEvents[eventName];\n    }\n\n    function findEventRegisteredNode(node, eventName) {\n        log("findEventRegisteredNode");\n        while (node && !checkEventRegistration(node, eventName)) {\n            node = node.parentNode;\n        }\n        if (node) {\n            return node;\n        }\n        if (checkEventRegistration(window, eventName)) {\n            return window;\n        }\n    }\n\n    function generateTouchEventProxyIfRegistered(eventName, touchPoint, target, eventObject, canBubble, relatedTarget) { // Check if user registered this event\n        log("generateTouchEventProxyIfRegistered");\n        if (findEventRegisteredNode(target, eventName)) {\n            generateTouchEventProxy(eventName, touchPoint, target, eventObject, canBubble, relatedTarget);\n        }\n    }\n\n    function getDomUpperHierarchy(node) {\n        var nodes = [];\n        if (node) {\n            nodes.unshift(node);\n            while (node.parentNode) {\n                nodes.unshift(node.parentNode);\n                node = node.parentNode;\n            }\n        }\n        return nodes;\n    }\n\n    function getFirstCommonNode(node1, node2) {\n        var parents1 = getDomUpperHierarchy(node1),\n            parents2 = getDomUpperHierarchy(node2),\n            lastmatch = null;\n\n        while (parents1.length > 0 && parents1[0] === parents2.shift()) {\n            lastmatch = parents1.shift();\n        }\n        return lastmatch;\n    }\n\n    // generateProxy receives a node to dispatch the event\n    function dispatchPointerEnter(currentTarget, relatedTarget, generateProxy) {\n        log("dispatchPointerEnter");\n        var commonParent = getFirstCommonNode(currentTarget, relatedTarget),\n            node = currentTarget,\n            nodelist = [];\n\n        while (node && node !== commonParent) { // target range: this to the direct child of parent relatedTarget\n            if (checkEventRegistration(node, "touchenter")) {\n                // check if any parent node has pointerenter\n                nodelist.push(node);\n            }\n            node = node.parentNode;\n        }\n        while (nodelist.length > 0) {\n            generateProxy(nodelist.pop());\n        }\n    }\n\n    // generateProxy receives a node to dispatch the event\n    function dispatchPointerLeave(currentTarget, relatedTarget, generateProxy) {\n        log("dispatchPointerLeave");\n        var commonParent = getFirstCommonNode(currentTarget, relatedTarget),\n            node = currentTarget;\n        while (node && node !== commonParent) {//target range: this to the direct child of parent relatedTarget\n            if (checkEventRegistration(node, "touchleave")) {\n                // check if any parent node has pointerleave\n                generateProxy(node);\n            }\n            node = node.parentNode;\n        }\n    }\n\n    function log(s) {\n        if (logToConsole) {\n            console.log(s.toString());\n        }\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    if (typeof (window.ontouchstart) === "object") {\n        return;\n    }\n\n    if (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i) || userAgent.match(/iPod/i) || userAgent.match(/Android/i) || (userAgent.match(/MSIE/i) && !userAgent.match(/Touch/i))) {\n        return;\n    }\n\n    // Add CSS to disable MS IE default scrolling functionality.\n    (function () {\n        var css = \'html { -ms-touch-action: none; }\',\n            head = document.head || document.getElementsByTagName(\'head\')[0],\n            style = document.createElement(\'style\');\n\n        style.type = \'text/css\';\n        if (style.styleSheet) {\n            style.styleSheet.cssText = css;\n        } else {\n            style.appendChild(document.createTextNode(css));\n        }\n\n        head.appendChild(style);\n    } ());\n\n    touchesWrapper = new TouchListWrapper();\n    changedTouchesWrapper = new TouchListWrapper();\n    targetTouchesWrapper = new TouchListWrapper();\n\n    window.CustomEvent = CustomEvent;\n\n    // Hooks\n    interceptAddEventListener(window);\n    interceptAddEventListener(window.HTMLElement || window.Element);\n    interceptAddEventListener(document);\n    interceptAddEventListener(HTMLBodyElement);\n    interceptAddEventListener(HTMLDivElement);\n    interceptAddEventListener(HTMLImageElement);\n    interceptAddEventListener(HTMLUListElement);\n    interceptAddEventListener(HTMLAnchorElement);\n    interceptAddEventListener(HTMLLIElement);\n    interceptAddEventListener(HTMLTableElement);\n    if (window.HTMLSpanElement) {\n        interceptAddEventListener(HTMLSpanElement);\n    }\n    if (window.HTMLCanvasElement) {\n        interceptAddEventListener(HTMLCanvasElement);\n    }\n    if (window.SVGElement) {\n        interceptAddEventListener(SVGElement);\n    }\n\n    interceptRemoveEventListener(window);\n    interceptRemoveEventListener(window.HTMLElement || window.Element);\n    interceptRemoveEventListener(document);\n    interceptRemoveEventListener(HTMLBodyElement);\n    interceptRemoveEventListener(HTMLDivElement);\n    interceptRemoveEventListener(HTMLImageElement);\n    interceptRemoveEventListener(HTMLUListElement);\n    interceptRemoveEventListener(HTMLAnchorElement);\n    interceptRemoveEventListener(HTMLLIElement);\n    interceptRemoveEventListener(HTMLTableElement);\n    if (window.HTMLSpanElement) {\n        interceptRemoveEventListener(HTMLSpanElement);\n    }\n    if (window.HTMLCanvasElement) {\n        interceptRemoveEventListener(HTMLCanvasElement);\n    }\n    if (window.SVGElement) {\n        interceptRemoveEventListener(SVGElement);\n    }\n\n    (function () {\n        // Returns true if and only if the event should be ignored.\n        function ignorePointerEvent(event) {\n            // Don\'t interpret mouse pointers as touches\n            if (event.pointerType === \'mouse\') {\n                return true;\n            }\n            // Don\'t interpret pointerdown events on the scrollbars as touch events.\n            // It appears to be the case that when the event is on the scrollbar in IE,\n            // event.x === 0 and event.y === 0\n            if (event.type === \'pointerdown\' && event.x === 0 && event.y === 0) {\n                return true;\n            }\n            // A user reported that when the input type is \'pen\', the pointermove event fires with a pressure of 0\n            // before the pen touches the screen.  We want to ignore this.\n            if (event.pointerType === \'pen\' && event.pressure === 0 && event.type === \'pointermove\') {\n                return true;\n            }\n            return false;\n        }\n\n        // Handling move on window to detect pointerleave/out/over\n        window.addEventListener(\'pointerdown\', function (eventObject) {\n            log("pointerdownfired");\n            var touchPoint = eventObject;\n\n            if (ignorePointerEvent(eventObject)) {\n                return;\n            }\n\n            previousTargets[touchPoint.identifier] = touchPoint.target;\n            generateTouchEventProxyIfRegistered("touchenter", touchPoint, touchPoint.target, eventObject, true);\n\n            // pointerenter should not be bubbled\n            dispatchPointerEnter(touchPoint.target, null, function (targetNode) {\n                generateTouchEventProxy("touchenter", touchPoint, targetNode, eventObject, false);\n            });\n\n            generateTouchEventProxyIfRegistered("touchstart", touchPoint, touchPoint.target, eventObject, true);\n        });\n\n        window.addEventListener(\'pointerup\', function (eventObject) {\n            var touchPoint = eventObject,\n                    currentTarget = previousTargets[touchPoint.identifier];\n\n            log("pointer up fired");\n\n            if (ignorePointerEvent(eventObject)) {\n                return;\n            }\n\n            generateTouchEventProxyIfRegistered("touchend", touchPoint, currentTarget, eventObject, true);\n            generateTouchEventProxyIfRegistered("touchleave", touchPoint, currentTarget, eventObject, true);\n\n            //pointerleave should not be bubbled\n            dispatchPointerLeave(currentTarget, null, function (targetNode) {\n                generateTouchEventProxy("touchleave", touchPoint, targetNode, eventObject, false);\n            });\n        });\n\n        window.addEventListener(\'pointermove\', function (eventObject) {\n            var touchPoint = eventObject,\n                    currentTarget = previousTargets[touchPoint.identifier];\n\n            log("pointer move fired");\n\n            if (ignorePointerEvent(eventObject)) {\n                return;\n            }\n\n            log(\'x: \' + eventObject.screenX + \', y: \' + eventObject.screenY);\n\n            // pointermove fires over and over when a touch-point stays stationary.\n            // This is at odds with the other browsers that implement the W3C standard touch events\n            // which fire touchmove only when the touch-point actually moves.\n            // Therefore, return without doing anything if the pointermove event fired for a touch\n            // that hasn\'t moved.\n            if (touchesWrapper.containsTouchAt(eventObject.screenX, eventObject.screenY)) {\n                return;\n            }\n\n            // If force preventDefault\n            if (currentTarget && checkPreventDefault(currentTarget) === true) {\n                eventObject.preventDefault();\n            }\n\n            generateTouchEventProxyIfRegistered("touchmove", touchPoint, currentTarget, eventObject, true);\n        });\n    } ());\n} ());\n\n//# sourceURL=smileycreations15://smilejs/modules/touchpolyfill.js';
function loadModule(module1){var moduleSrc=moduleCache[module1];var module={exports:{}};eval(moduleSrc);return module.exports}eval('if (this.window) loadModule("core-main.js");\n\n//# sourceURL=smileycreations15://smilejs/index.js')})();
//# sourceURL=smileycreations15://smilejs/raw/bundle.js
